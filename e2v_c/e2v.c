//#include "main.c"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <pthread.h>

#define MAX_STRING 100
#define EXP_TABLE_SIZE 1000
#define MAX_EXP 6
#define MAX_CODE_LENGTH 40

float *entity_vector, *neg_entity_vector, *expTable;
unsigned int *wordvector2idx, n_prod = 0, n_pair = 0,
        layer1_size = 200, *negative_sampling_table, n_thread = 5, max_iter = 5, n_negative = 5;
char vector_file[MAX_STRING] = "/home/sanqiang/data/glove/glove.twitter.27B.200d.txt", pair_file[MAX_STRING] = "/home/sanqiang/git/entity2vector/yelp_rest_allalphaword_yelp_mincnt10_win10/pairentity.txt",
        output_file[MAX_STRING] = "/home/sanqiang/git/entity2vector/yelp_rest_allalphaword_yelp_mincnt10_win10/pairentity.txt", prod_file[MAX_STRING] = "/home/sanqiang/git/entity2vector/yelp_rest_allalphaword_yelp_mincnt10_win10/output.txt";
long long wordvectorsize = 300000;
struct wordvector* idx2wordvector;
struct pair* pairs;
struct prod* idx2prod;
float alpha = 0.025;

const int table_size = 1e8;
const int vocab_hash_size = 30000000;

struct wordvector{
    char* word;
    float* vector;
    int* prods;
};

struct prod{
    char* prod_str;
    unsigned int cnt;
};

struct pair{
    unsigned int prod;
    unsigned int token;
};

char* concat(char *s1, char *s2)
{
    char *result = malloc((strlen(s1)+strlen(s2)+1)* sizeof(char));//+1 for the zero-terminator
    //in real code you would check for errors in malloc here
    strcpy(result, s1);
    strcat(result, s2);
    return result;
}

int get_hash(char* word){
    unsigned int i, hash = 0;
    for (i = 0; i < strlen(word); i++) hash = hash * 257 + word[i];
    hash = hash % vocab_hash_size;
    return hash;
}

int get_vector_idx(char *word){
    unsigned int hash = get_hash(word);
    while (1) {
        if (wordvector2idx[hash] == -1) return -1;
        if (!strcmp(word, idx2wordvector[wordvector2idx[hash]].word)) return wordvector2idx[hash];
        hash = (hash + 1) % vocab_hash_size;
    }
    return -1;
}

void populate_prod(){
    idx2prod = (struct prod *)malloc ((size_t) ((n_prod + 1) * sizeof(struct prod)));
    FILE *fin;
    fin = fopen(prod_file, "rb");
    char ch, prodstr[MAX_STRING], prodidx[MAX_STRING];;
    unsigned int word_idx = 0, prod_size = 0, mode = 0; //0 refer word mode and 1 refer to integer mode
    while (!feof(fin)) {
        ch = fgetc(fin);
        if(ch == '\n'){
            prodstr[word_idx] = '\0';
            idx2prod[prod_size].prod_str = (char *)calloc(word_idx, sizeof(char));
            strcpy(idx2prod[prod_size].prod_str,prodstr);
            idx2prod[prod_size].cnt = 0;
            prod_size++;
        }
        else{
            prodstr[word_idx] = ch;
            word_idx++;
        }
    }
}

void populate_wordvector(){
    idx2wordvector = (struct wordvector *)malloc ((size_t) ((wordvectorsize + 1) * sizeof(struct wordvector)));

    FILE *fin;
    fin = fopen(vector_file, "rb");
    char ch, word[MAX_STRING], num[MAX_STRING];
    unsigned int word_idx = 0, vector_idx = 0, cur_vector_size = 0, hash, i;
    unsigned int mode = 0; //0 refer word mode and 1 refer to integer mode

    while (!feof(fin)) {
        ch = fgetc(fin);

        if(ch == '\n'){
            word[word_idx] = '\0';
            idx2wordvector[cur_vector_size].vector[vector_idx] = atof(num);
            vector_idx = 0;
            word_idx = 0;
            cur_vector_size++;
            mode = 0;
        }else if(ch == ' '){
            word[word_idx] = '\0';
            if(mode == 0){
                idx2wordvector[cur_vector_size].prods = (int *)calloc(n_prod, sizeof(int));
                for(i=0;i<n_prod;i++){
                    idx2wordvector[cur_vector_size].prods = 0;
                }
                idx2wordvector[cur_vector_size].word = (char *)calloc(word_idx, sizeof(char));
                strcpy(idx2wordvector[cur_vector_size].word,word);

                hash = get_hash(word);
                while (wordvector2idx[hash] != -1) hash = (hash + 1) % vocab_hash_size;
                wordvector2idx[hash] = cur_vector_size;

                idx2wordvector[cur_vector_size].vector = (float *)calloc(layer1_size, sizeof(float));
                mode = 1;
            }else if(mode == 1){
                idx2wordvector[cur_vector_size].vector[vector_idx] = atof(num);
                vector_idx++;
            }
            word_idx = 0;
        }
        else{
            if(mode == 0){
                word[word_idx] = ch;
                word_idx++;
            }else if(mode == 1){
                num[word_idx] = ch;
                word_idx++;
            }
        }
    }
}

void populate_pair(){
    pairs = (struct pair *)malloc ((size_t) ((n_pair + 1) * sizeof(struct pair)));

    FILE *fin;
    fin = fopen(pair_file, "rb");
    char ch, word[MAX_STRING];
    unsigned int word_idx = 0, prod_indx, token_idx, hash, prod_size = 0, pair_size = 0;

    while (!feof(fin)) {
        ch = fgetc(fin);
        if(ch == '\n'){
            word[word_idx] = '\0';
            token_idx = get_vector_idx(word);
            idx2wordvector[token_idx].prods[prod_indx] = 1;

            pairs[pair_size].prod = prod_indx;
            pairs[pair_size].token = token_idx;
            pair_size++;

        }else if(ch == ' '){
            word[word_idx] = '\0';
            prod_indx = atoi(word);
            idx2prod[prod_indx].cnt++;

            word_idx = 0;
        }else{
            word[word_idx] = ch;
            word_idx++;
        }
    }
}

void init_negative_sampling_table() {
    long long train_words_pow = 0, a, i;
    float d1, power = 0.75;
    negative_sampling_table = (int *)malloc(table_size * sizeof(int));
    for (a = 0; a < n_prod; a++) train_words_pow += pow(idx2prod[a].cnt, power);
    i = 0;
    d1 = pow(idx2prod[i].cnt, power) / (float)train_words_pow;
    for (a = 0; a < table_size; a++) {
        negative_sampling_table[a] = i;
        if (a / (float)table_size > d1) {
            i++;
            d1 += pow(idx2prod[i].cnt, power) / (float)train_words_pow;
        }
        if (i >= n_prod) i = n_prod - 1;
    }
}

void init(){
    //populate exp precomputing table
    int i;
    expTable = (float *)malloc((EXP_TABLE_SIZE + 1) * sizeof(float));
    for (i = 0; i < EXP_TABLE_SIZE; i++) {
        expTable[i] = exp((i / (float)EXP_TABLE_SIZE * 2 - 1) * MAX_EXP); // Precompute the exp() table
        expTable[i] = expTable[i] / (expTable[i] + 1);                   // Precompute f(x) = x / (x + 1)
    }

    //init hash table
    wordvector2idx = (int *)calloc(vocab_hash_size, sizeof(int));
    for (i = 0; i < vocab_hash_size; i++) wordvector2idx[i] = -1;
    populate_wordvector();

    populate_prod();

    populate_pair();

    init_negative_sampling_table();

    //init net
    long long a, b;
    a = posix_memalign((void **)&entity_vector, 128, (long long)n_prod * layer1_size * sizeof(float));
    if (entity_vector == NULL) {printf("entity_vector memory allocation failed\n"); exit(1);}
    /*a = posix_memalign((void **)&neg_entity_vector, 128, (long long)n_prod * layer1_size * sizeof(float));
    if (neg_entity_vector == NULL) {printf("neg_entity_vector memory allocation failed\n"); exit(1);}
    for (a = 0; a < n_prod; a++){
        for (b = 0; b < layer1_size; b++) {
            neg_entity_vector[a * layer1_size + b] = 0;
        }
    }*/

    unsigned long long next_random = 1;
    for (a = 0; a < n_prod; a++){
        for (b = 0; b < layer1_size; b++) {
            next_random = next_random * (unsigned long long)25214903917 + 11;
            entity_vector[a * layer1_size + b] = (((next_random & 0xFFFF) / (float)65536) - 0.5) / layer1_size;
        }
    }
}

void train_thread(void *id) {
    unsigned long long next_random = (long long)id;
    long long thread_id = (long long)id;

    long long pos_st = n_pair / n_thread * thread_id;
    long long pos_ed = n_pair / n_thread * (1 + thread_id);

    long long pos = pos_st, last_pos=0;
    long long i, c, l1;
    float f, g;
    int label;
    printf("current thread start! start pos %llu and end pos %llu. \n", pos_st, pos_ed);
    float *neu1 = (float *)calloc(layer1_size, sizeof(float)); // 隐层节点
    float *neu1e = (float *)calloc(layer1_size, sizeof(float)); // 误差累计项，其实对应的是Gneu1

    while (1){

        if(pos - last_pos >= 10000){
            last_pos = pos;
            printf("%cProgress: %.2f%%  ", 13,  (n_thread * (last_pos+pos)) / (float)(max_iter * n_pair + 1) * 100);
            fflush(stdout);
        }

        struct pair pair = pairs[pos]; //to update
        unsigned short context = pair.prod;
        unsigned short target = pair.token;
        pos++;

        l1 = context * layer1_size; //location in the hidden layer, update him rather than word

        for (c = 0; c < layer1_size; c++) neu1[c] = 0;
        for (c = 0; c < layer1_size; c++) neu1e[c] = 0;

        for (i = 0; i <= (n_negative+1); ++i) {
            if(i == 0){
                label = 1;
            }
            else{
                label = 0;
                next_random = next_random * (unsigned long long)25214903917 + 11;
                target = negative_sampling_table[(next_random >> 16) % table_size];
                while(idx2wordvector[target].prods[context] == 0){
                    next_random = next_random * (unsigned long long)25214903917 + 11;
                    target = negative_sampling_table[(next_random >> 16) % table_size];
                }
            }

            f = 0;
            for (c = 0; c < layer1_size; c++) f += entity_vector[c + l1] * idx2wordvector[target].vector[c];
            if (f > MAX_EXP) g = (label - 1) * alpha;else if (f < -MAX_EXP) g = (label - 0) * alpha;
            else g = (label - expTable[(int)((f + MAX_EXP) * (EXP_TABLE_SIZE / MAX_EXP / 2))]) * alpha;
            for (c = 0; c < layer1_size; c++) neu1e[c] += g * idx2wordvector[target].vector[c];
        }
        for (c = 0; c < layer1_size; c++) entity_vector[c + l1] += neu1e[c];

        if(pos >= pos_ed){
            //printf("finished one loop for one thread %llu. \n", thread_id);
            break;
        }
    }
    free(neu1);
    free(neu1e);
    pthread_exit(NULL);
}

void conclude(int ind){
    char str[15];
    sprintf(str, "%d", ind);
    char * path = concat(output_file, str);
    printf("Path: %s \n", path);
    FILE *fo;
    fo = fopen(path, "wb");
    long long a, b;
    fprintf(fo, "%lld %lld\n", n_prod, layer1_size);
    for (a = 0; a < n_prod; a++) {
        fprintf(fo, "%s ", idx2prod[a].prod_str);
        if (0) for (b = 0; b < layer1_size; b++)
                fwrite(&entity_vector[a * layer1_size + b], sizeof(float), 1, fo);
        else for (b = 0; b < layer1_size; b++)
                fprintf(fo, "%lf ", entity_vector[a * layer1_size + b]);
        fprintf(fo, "\n");
    }
    fclose(fo);
}

void train(){
    int i, p;
    pthread_t *pt = (pthread_t *)malloc(n_thread * sizeof(pthread_t));
    for(i = 0; i < 2147400000; i++){
        for (p = 0; p < n_thread; p++) pthread_create(&pt[p], NULL, train_thread, (void *)p);
        for (p = 0; p < n_thread; p++) pthread_join(pt[p], NULL);
        conclude(i);
    }
}

int main(int argc, char **argv) {
    init();
    train();

    exit(0);
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           